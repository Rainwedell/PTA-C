//法一
 //                          这里表示和数组的哪个位置换    m=M%N = 4
 //0 1 2 3 4 5 6 7 8 9 10    0    a[0]这里是换的定点，本例无特殊情况为a[0]，法二例子存在特殊情况，定点会＋1)
// 4 1 2 3 0 5 6 7 8 9 10    4
// 8 1 2 3 0 5 6 7 4 9 10    8
 //1 8 2 3 0 5 6 7 4 9 10    4-(11-9)-1=1
 //5 8 2 3 0 1 6 7 4 9 10    5 
 //9 8 2 3 0 1 6 7 4 5 10    9
 //2 8 9 3 0 1 6 7 4 5 10    4-(11-9-1)-1=2
 //6 8 9 3 0 1 2 7 4 5 10    6
 //10 8 9 3 0 1 2 7 4 5 6    10
 //3 8 9 10 0 1 2 7 4 5 6    4-(11-10-1)-1 = 3
 //7 8 9 10 0 1 2 3 4 5 6    7
//一共循环N-1次 

 //法二 （提交到pta）
 // 1 2 3 4 5 6        m=M%N = 4
 // 1 2 3 4 || 5 6      //分段
 // 4 3 2 1 || 6 5      //逆序  循环(N-M%N)/2+(M%N)/2 次
 // 4 3 2 1 6 5         //合
 // 5 6 1 2 3 4         /再逆序 循环 N/2次
 //循环 N 次 看起来更精巧，其实b复杂度一样都是O（N）...
#include<stdio.h>
int main(void)
{
    int N,M;
    scanf("%d %d",&N,&M);
    //if(M>N) M%=N;//处理M大于N的情况，本身循环等价，当M>N时见38行注释
    int a[N];
    for (int i = 0; i < N; i++)
    {
        scanf("%d",&a[i]);
    }
    int t = -1;
    int x = 0; 
    int y = 0;
    for (int i = 0; i < N-1; i++)
    {
        if(x+M<=N-1)
        {
            x+=M;
            t = a[y];a[y]=a[x];a[x]=t;
            //x+=M;
        }
        else
        {
            x=M-(N-x-1)-1;//若M>N，程序每次都会直接进入这个分支，则x=M-(N-x-1)-1  ->  x=x+M-N数组a[x]在M-N大于1就时发生越界：因为此算法其实是以a[0]为定点进行N-1次交换，每交换一次都会把一个数排列到目标位置
            if (x!=0)     //(若a[0]在交换过程中已经为目标值，则本次不交换，把定点移至下一位a[1],以此类推)，for循环共控制了N-1次，当M-N = 1时，a[x]再最后一次循环刚好到边界,x = N-1;
            {
                t = a[y];a[y]=a[x];a[x]=t;
            }
            else
            {
                x++;
                y++;
            
            }
            
            //t = a[0];a[0]=a[x];a[x]=t;
            //x=M-(N-x-1)-1;
        }
    }
    for (int i = 0; i < N; i++)
    {
        printf("%d",a[i]);
        if (i<N-1)
        {
            printf(" ");
        }
        
    }
    return 0;
    
}